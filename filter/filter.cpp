/*#############################################################################
  
  # LocHap : Local-Haplotype Variant Calling Software.
  # Copyright (C) <2014>  <Subhajit Sengupta and Kamalakar Gulukota>
  # This file is part of LocHap.

  #  LocHap is free software: you can redistribute it and/or modify
  #  it under the terms of the GNU General Public License as published by
  #  the Free Software Foundation, either version 3 of the License, or
  #  (at your option) any later version.

  #  LocHap is distributed in the hope that it will be useful,
  #  but WITHOUT ANY WARRANTY; without even the implied warranty of
  #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  #  GNU General Public License for more details.

  #  You should have received a copy of the GNU General Public License
  #  along with LocHap. If not, see <http://www.gnu.org/licenses/>.
  ############################################################################  


##############################################################################*/
/********************************************************
*********************************************************

	This is the main code for Optional Filtering
	Developed by: Subhajit Sengupta
	July 2014
	input: hcf (generated by LocHap) ,bam + bai and associated vcf
    output: hcf
	
	NOTE:
		VCF,HCF --- corordinate are based on 1
		BAM		--- corordinate are based on 0


	Three variations of Filters
	1) Type I (Tail Filters) -- argument "filter-type" = 1 --- nHaplo > 2 and nClus > 2 and min_SNP_dist = short_RL  
	2) Type II (Leg Filters) -- argument "filter-type" = 2 --- nHaplo > 2 and min_SNP_dist = short_RL 
	3) Type III (Elephant Filters) -- argument "filter-type" = 3 --- nHaplo > 2 and min_SNP_dist = short_RL/2 

	Details on filtering can be found in Online Methods of the paper
	titled "Local-Haplotype Variant Calling 
  			Reveals Cellular Heterogeneity and Somatic Mosaicism" 
	by Sengupta et al.

	Fisher-exact-test for checking strand bias.


*********************************************************
*********************************************************/

#include "filter.h" 

using namespace std;
using namespace BamTools;

//#define ONLY_MUTATION_DIR_READ


/**********************************	
main function:
 
Input: arguments to run the filter program from console
Output: generate file in the specified directory

-- Initialized count for all the counters required for Level_1(HCF), Level_2 (VCF) and Level_3(BAM) filters.
-- Read each block in the HCF file.
-- Apply level-1 filter first on one block.
-- Next apply Level-2 filter if the block passes level-1 filter.  
-- Next apply level-3 filter if the block passes level-2 filter. 
-- Finally write that block to hcf2 file if the block passes all the filters.
-- Generate a summary statistics of the given HCF file and the applied filters. 

***********************************/
int main(int argc,char* argv[])
{
	if(argc < 7)
	{
		cerr << "Please enter ./filter <hcf file name> <bam file name> <vcf file name> <sample name> <output directory> <Filter_type (1 for type I or 2 for type II or 3 for type III)> \n\n";
		cerr << ">>>>> Error: User command error !\n";
		return 0;
	}
	
	cout << "===================================================\n";

	string inHcfFileName(argv[1]);

	cout << "HCF file: " << inHcfFileName << endl; 
	ifstream inHcfFs(inHcfFileName.c_str() );
	if (!inHcfFs.is_open())
	{
		cout << "could not open HCF file !!!\n";
		exit(-1);
	}
	string outputFileName;
	outputFileName.assign(argv[5]);/// output directory
	outputFileName.append("/");
	outputFileName.append(argv[4]);/// sample_name 
	outputFileName.append(".hcf");/// <out_dir>/<sample_name>.hcf
	
	ofstream outLHFs(outputFileName.c_str());	
	outLHFs << "##All the LHs those are filtered\n";
	outLHFs << "##--------------------------------\n";
	
	int filterType = TAIL_FILTER;
	filterType = atoi(argv[6]);
	string filterType_str;	

	filterType = filterType - 1;
	if(filterType == 0)
		filterType_str.assign("TAIL");
	else 
	{
		if(filterType == 1)
			filterType_str.assign("LEG");
		else
		{
			if (filterType == 2)
				filterType_str.assign("ELEPHANT");
			else
			{
				cout << "no such filter type!\n";
				exit(-1);
			}	
		}
	}

	cout << "Starting " << filterType_str << " Filter analysis ... \n";

	string inBamFileName(argv[2]);
	string inBamIndexFileName;
	
	// open using BamReader
	BamReader bR;
	if ( !bR.Open(inBamFileName) ) 
	{
		cerr << "Could not open input BAM files." << endl;
		exit(-1);
	}
	
	string hStr;
	hStr = bR.GetFilename();
	cout << "BAM file name: " << hStr << endl;
	//cout << "BAM header read " << endl;
	//hStr = bR.GetHeaderText();
	//cout <<  hStr << endl;
	SamHeader sH;
	sH = bR.GetHeader();
	
	//////// VCF part
	vector<vcfInfo> vcfVector;
	cout << "VCF file: " << argv[3] << endl;
	cout << "Sample: "<<argv[4] << endl;
	cout << "OUTPUT File Name : " << outputFileName << endl; 

	/// some constants calculation for the filters
	int short_RL = determine_short_RL_from_BAM(bR);
	//cout << "Short-Read-Length in this BAM = " << short_RL << endl;
	
	getVCFInfo(argv[3],argv[4],sH,vcfVector);
	////////////////////
	vector<idPos> SNPVec;
	vector<idPos> INDELVec;

	for(size_t i =0;i<vcfVector.size();i++)
	{	
		idPos iP;
		iP.chrID = vcfVector[i].iP.chrID;
		iP.pos = vcfVector[i].iP.pos;
		if(vcfVector[i].infoType == HETEROZYGOUS)	
			SNPVec.push_back(iP);
		if(vcfVector[i].infoType == INDEL)
			INDELVec.push_back(iP);	
	}
	//cout << "vcf vector length " << vcfVector.size() << endl;

	//cout << "SNP Sites: (" << SNPVec.size() <<")" << endl;
	//cout << "INDEL Sites: (" << INDELVec.size() <<")" << endl;
	

	inBamIndexFileName += inBamFileName;
	inBamIndexFileName += ".bai";
	
	bool iF;
	iF = bR.OpenIndex(inBamIndexFileName);
	if(iF == true)
		;//cout << " success: opened the index file" << endl;
	else
	{
		//cout << inBamIndexFileName <<" NOT found" << endl; 
		inBamIndexFileName = "";
		int prefix_endPos = inBamFileName.find(".bam");
		char tmpName[MAX_LINE_LEN];
		inBamFileName.copy(tmpName,prefix_endPos,0);
		tmpName[prefix_endPos] = '\0';	
		string tmpStr(tmpName);
		inBamIndexFileName += tmpStr;	
		inBamIndexFileName += ".bai";

		//cout << inBamIndexFileName <<" found" << endl; 

		iF = bR.OpenIndex(inBamIndexFileName);  
		if(iF == true)
			;//cout <<" success opening Index file" << endl;
		else
		{
			cout << " it could NOT open the Index file" << endl;
			exit(-1);
		}	
	}
	//cout << "Index File name = " << inBamIndexFileName << endl;	
	

	/*
	// retrieve 'metadata' from BAM files, these are required by BamWriter
	const SamHeader header = reader.GetHeader();
	const RefVector references = reader.GetReferenceData();
	*/
	
	cout << "===================================================\n";

	int nSNP;
	char refSeq[MAX_SNP];
	long posSNP[MAX_SNP];
	string chrName;

	string tStr;
	//string tStr1;

	vector<LH_block> hcf_blocks;
	int nFilteredLine = 0;

	int total_block_cnt = 0; // total block count in the HCF file
 	int level_1_filter_rem_cnt = 0; // number of blocks removed by level-1 filters
 	int level_1_subfilter_rem_cnt_1 = 0; // number of blocks removed by level-1 subfilter -- SNP distance
 	int level_1_subfilter_rem_cnt_2 = 0; // number of blocks removed by level-1 subfilter -- nHaplo > 3 [and nClus > 3]
    
	int level_2_filter_rem_cnt = 0; // number of blocks removed by level-2 filters
	int level_2_subfilter_rem_cnt_1 = 0; // number of blocks removed by level-2 subfilter -- SNP exists in VCF
	int level_2_subfilter_rem_cnt_2 = 0; // // number of blocks removed by level-2 filter -- INDEL region exists in VCF
 	
	int level_3_filter_rem_cnt = 0; // number of blocks removed by level-3 filters
 	int level_3_subfilter_rem_cnt_1 = 0; // number of blocks removed by level-3 subfilter
 	int level_3_subfilter_rem_cnt_2 = 0; // number of blocks removed by level-3 subfilter
 	int level_3_subfilter_rem_cnt_3 = 0; // number of blocks removed by level-3 subfilter
 	int level_3_subfilter_rem_cnt_4 = 0; // number of blocks removed by level-3 subfilter
 	int level_3_subfilter_rem_cnt_5 = 0; // number of blocks removed by level-3 subfilter
	//total_block_cnt = level_1_filter_rem_cnt+level_2_filter_rem_cnt+level_3_filter_rem_cnt;

	// iterate through all alignments, only counting ones with high map quality
	BamAlignment al;
	
	int tmpType = 0;
    while( getline(inHcfFs,tStr) ) /// parse the HCF file
	{
		if(tStr.size() > 1 && tStr.at(0) != '#' )//// if it is not a comment in HCF file
		{
			//cout << tStr << endl;
			total_block_cnt++;
			LH_block LH_blk;
			initBlockStat(LH_blk);		
			LH_blk.blockStr.assign(tStr);	
			
			char* tmpName;
			char* inLineStr;
			tmpName = new char[10];
			inLineStr = new char[10000];
			strcpy(inLineStr,tStr.c_str());
			//cout << "begin: \n" << inLineStr << endl;
			for(int i=0;i<MAX_SNP;i++)
            	refSeq[i] = '\0';
			/// Level-1 filter based on HCF file	
			iF = Level_1_Filtering_HCF(inLineStr,tmpName,&nSNP,posSNP,refSeq,&tmpType,short_RL,filterType); // Level-1 filtering
			if(iF == false)		
			{
				level_1_filter_rem_cnt++;
				if(tmpType == 1)
					level_1_subfilter_rem_cnt_1++;
				if(tmpType == 2)
					level_1_subfilter_rem_cnt_2++;
				
				//cout << "Block# " << total_block_cnt << " : Level-1(HCF)-Filter: NOT PASSED !" << endl;
				continue;
			}
			else
			{
				cout << "===============================\n";
				cout << "Block# " << total_block_cnt << " : Level-1(HCF)-Filter: PASSED !" << endl;
			}

			nFilteredLine++;
			chrName.assign(tmpName);
			LH_blk.chrName.assign(chrName);	
			LH_blk.nSNP = nSNP;	

			int refID = bR.GetReferenceID(chrName);

			// if for all the SNPs in a block the reads are good
			// then only it wil be regarded as a confirmed LHV
			for(int i=0;i<nSNP;i++)
			{
				
				LH_blk.readInfoSNP[i].posSNP = posSNP[i];
				LH_blk.readInfoSNP[i].refSeq = refSeq[i];
				//cout << "Chr: " << refID+1 << " Loc: " << posSNP[i] << " Ref: "<< refSeq[i] << endl;
				/// find out from vcf if we have nearby SNP or INDEL postions	
				idPos tmpIdPos;
				tmpIdPos.chrID = refID;
				tmpIdPos.pos = posSNP[i];
				
				/// check for near by SNP or INDEL
				/// Level-2 filtering using VCF	
				bool bFlag = Level_2_Filtering_VCF(tmpIdPos,SNPVec,INDELVec,&tmpType,short_RL,filterType); /// Level-2 filtering
				if(bFlag == false)
				{
					LH_blk.readInfoSNP[i].goodSNP = false;	
					LH_blk.goodBlock = false;
					level_2_filter_rem_cnt++;
					if(tmpType == 1)
						level_2_subfilter_rem_cnt_1++;
					if(tmpType == 2)
						level_2_subfilter_rem_cnt_2++;
					//cout << "Block# " << total_block_cnt << " : Level-2(VCF)-Filter: NOT PASSED !" << endl;
					break;
				}
				else
				{
					cout << "===============================\n";
					cout << "Block# " << total_block_cnt << " : Level-2(VCF)-Filter: PASSED !" << endl;

				}
				/// this setting of region is stricter 
				/// I think, it is better to keep the start and end
				/// position of the region to be the same 
				/// HALF-OPEN interval [a,b)
				bR.SetRegion(refID,posSNP[i]-1,refID,posSNP[i]);	
			
				// reset all the counts
	
				LH_blk.readInfoSNP[i].n_total_mapped_read = 0;
				LH_blk.readInfoSNP[i].n_total_hQ_mapped_read = 0;
				LH_blk.readInfoSNP[i].n_total_no_indel_read = 0;
				LH_blk.readInfoSNP[i].n_total_hQ_base_read = 0;
				LH_blk.readInfoSNP[i].n_total_not_end_read = 0;
				LH_blk.readInfoSNP[i].n_total_good_read = 0;

				LH_blk.readInfoSNP[i].n_tot_pos_direction_read = 0;	
				LH_blk.readInfoSNP[i].n_mut_pos_direction_read = 0;	
				LH_blk.readInfoSNP[i].n_tot_neg_direction_read = 0;	
				LH_blk.readInfoSNP[i].n_mut_neg_direction_read = 0;	
	
				/// Level-3 Filtering using sample's BAM file
				bool zFlag = Level_3_Filtering_BAM(bR,al,LH_blk,i,posSNP,refSeq,short_RL,
												   level_3_subfilter_rem_cnt_1,
												   level_3_subfilter_rem_cnt_2,
												   level_3_subfilter_rem_cnt_3,
												   level_3_subfilter_rem_cnt_4);
													

				if(zFlag == false)
				{
					level_3_filter_rem_cnt++;
					if(LH_blk.readInfoSNP[i].n_total_good_read > 0)
						level_3_subfilter_rem_cnt_5++;
					cout << "===============================\n";
					cout << "Block# " << total_block_cnt << " : Level-3(BAM)-Filter: NOT PASSED !" << endl;
					/// too much one direction read
					//cout << "Read One Direction problem !!! "<< "ratio is: "<< max_prop_dir <<endl;
					//cout << "+ reads: " << LH_blk.readInfoSNP[i].n_pos_direction_read << "\t";
					//cout << "- reads: " << LH_blk.readInfoSNP[i].n_neg_direction_read << "\n";
					//cout << "SNP pos: " << LH_blk.readInfoSNP[i].posSNP << endl;
					LH_blk.readInfoSNP[i].goodSNP = false;	
					LH_blk.goodBlock = false;
					break;
				}
				else
				{
					cout << "===============================\n";
					cout << "Block# " << total_block_cnt << " : Level-3(BAM)-Filter: PASSED !" << endl;
					//cout << "Read One Direction ! "<< "ratio is: "<< max_prop_dir <<endl;
					LH_blk.readInfoSNP[i].goodSNP = true;
				}

			} /// end for: all SNPs
			if(nSNP == 2)
			{
				if(LH_blk.readInfoSNP[0].goodSNP && LH_blk.readInfoSNP[1].goodSNP)
				{
					LH_blk.goodBlock = true;
					cout << "All-Filters: PASSED !" << endl;
					cout << "This Block : GOOD" << endl;
				}
				else
				{		
					cout << "All-Filters: NOT PASSED !" << endl;
					cout << "This Block : NOT GOOD" << endl;
					LH_blk.goodBlock = false;
				}	
			}	
			if(nSNP == 3)
			{
				if(LH_blk.readInfoSNP[0].goodSNP && LH_blk.readInfoSNP[1].goodSNP && LH_blk.readInfoSNP[2].goodSNP)
				{
					cout << "This Block is GOOD" << endl;
					LH_blk.goodBlock = true;
				}
				else
				{
					cout << "This Block is NOT GOOD" << endl;
					LH_blk.goodBlock = false;
				}
			}		

			hcf_blocks.push_back(LH_blk);
			cout << "===============================\n";
			
    	} /// end if: for one HCF line
		else  /// print the comment strings
			outLHFs << tStr << endl;
			
	
	} /// end while: reading the entire HCF file 

	cout << "===================================================\n";


	int nConfirmedLHBlocks = 0;	
	for(size_t i=0;i<hcf_blocks.size();i++)
	{
		if(hcf_blocks[i].goodBlock)
		{	
			nConfirmedLHBlocks++;	
			outLHFs << hcf_blocks[i].blockStr << endl;
		}	
	}
	cout << endl;
	cout << "Summary of " << filterType_str << " Filtering:\n";
	cout << "---------------------------------------------------\n";
	cout << total_block_cnt <<" Total Blocks in HCF File\n";
	int tot_accnt_blk_cnt = level_1_filter_rem_cnt+level_2_filter_rem_cnt
							+level_3_filter_rem_cnt+nConfirmedLHBlocks;	
	cout << tot_accnt_blk_cnt <<" Total Tracked Blocks (Level-1/2/3 Filtered Out + Remaining blocks)\n";	
	
	cout << level_1_filter_rem_cnt <<" Level-1 Filtered Blocks" << "( " << 
			level_1_subfilter_rem_cnt_1 <<" + "<<
			level_1_subfilter_rem_cnt_2 <<" = "<< level_1_subfilter_rem_cnt_1+level_1_subfilter_rem_cnt_2 <<" )\n";

	cout << level_2_filter_rem_cnt <<" Level-2 Filtered Blocks "<<"( "
	<< level_2_subfilter_rem_cnt_1 <<" + " << level_2_subfilter_rem_cnt_2 <<" )\n";  
	

	cout << level_3_filter_rem_cnt <<" Level-3 Filtered Blocks " <<"( " 
	<< level_3_subfilter_rem_cnt_1 <<" + " << level_3_subfilter_rem_cnt_2 <<" + "  
	<< level_3_subfilter_rem_cnt_3 <<" + " << level_3_subfilter_rem_cnt_4 << " + " 
	<< level_3_subfilter_rem_cnt_5 << " )\n";
	
	//cout << nFilteredLine <<" Basic-Filtered Blocks in HCF !!\n";
	cout << nConfirmedLHBlocks <<" Final Advanced-Filtered Blocks remain in HCF !!\n";
	cout << "===================================================\n";
	

	// close the reader
	bR.Close();
	inHcfFs.close();
	outLHFs.close();

	return 0;

}

/**
	Input: BAM reader pointer 
	Output: length of the short read 
	
	-- determine short read length from the given BAM file

*/
int determine_short_RL_from_BAM(BamReader& bR)
{
	BamAlignment B;
	int short_RL = 50;

	while(bR.GetNextAlignment(B))
	{
		if(B.CigarData.size()==1)
		{
			//cout << "CIGAR: " << B.CigarData[0].Length << B.CigarData[0].Type << endl;
			if(B.CigarData[0].Type == 'M') 
			{
				short_RL = B.CigarData[0].Length;
				break;
			}
		}			
		else
			continue;
		
	}

	return short_RL;

}

/**
	Input: LH_block structure reference
	Output:

	-- initializes stats on the block
*/
void initBlockStat(LH_block& L)
{
	L.blockStr.assign("NA");
	L.chrName.assign("NA");
	L.nSNP = 0;
	for(int i=0;i<MAX_SNP;i++)
		initSNPReadInfo(L.readInfoSNP[i]);
	L.goodBlock = false; 
}

/**
	Input: SNP_readInfo structure reference
	Output:

	-- initialize all the information associated with one SNP in the set of SNPs of the block 
*/
void initSNPReadInfo(SNP_readInfo& S)
{
	S.posSNP = -1;
 	S.refSeq = 'Z'; // place-holder
 	S.altSeq = 'Z'; // the top one other than the ref seq character 
    S.n_total_mapped_read = 0;
    S.n_total_hQ_mapped_read = 0;
    S.n_total_no_indel_read = 0;/// passed mapping quality
    S.n_total_hQ_base_read = 0;/// passed mapping quality
    S.n_total_not_end_read = 0;/// passed mapping quality
    S.n_total_good_read = 0;/// passed mapping quality
    //S.n_low_baseQual_read = 0;
    S.n_pos_direction_read = 0;
    S.n_neg_direction_read = 0;

    S.n_tot_pos_direction_read = 0;
    S.n_mut_pos_direction_read = 0;
    S.n_tot_neg_direction_read = 0;
    S.n_mut_neg_direction_read = 0;

	S.n_nearby_SNP = 0;
    S.n_nearby_indel = 0;
    //S.n_end_readBase = 0;
    S.goodSNP = false;
}

/**
	Input: SNP_readInfo structure reference and file pointer
	Output:
	-- writes information regarding a particular SNP
*/
void print_SNP_readInfo(SNP_readInfo& S,ofstream &outFs)
{
	outFs << "SNP pos: " << S.posSNP << endl;
	outFs << "ref Seq: " << S.refSeq << endl;
	outFs << "alt Seq: " << S.altSeq << endl;
	outFs << "total mapped read: " << S.n_total_mapped_read << ",";
	outFs << "total hQ-mapped read: " << S.n_total_hQ_mapped_read << ",";
	outFs << "total no-indel reads: " << S.n_total_no_indel_read << ",";
	outFs << "total hQ-base reads: " << S.n_total_hQ_base_read << ",";
	outFs << "total not-end reads: " << S.n_total_not_end_read << ",";
	//outFs << "low base qual reads: " << S.n_low_baseQual_read << ",";
	outFs << "pos/neg direction reads: " <<  S.n_pos_direction_read <<"/" << S.n_neg_direction_read << ",";
	outFs << "nearby SNP reads: " << S.n_nearby_SNP << endl;
	outFs << "nearby indels: " << S.n_nearby_indel << endl;
	//outFs << "end variations: " << S.n_end_readBase << endl;		
}

/**
	Input: SNP_readInfo structure reference
	Output:
	-- writes information regarding a particular SNP on STDOUT
*/
void print_SNP_readInfo(SNP_readInfo& S)
{
	cout << "SNP pos: " << S.posSNP << endl;
	cout << "ref Seq: " << S.refSeq << endl;
	cout << "alt Seq: " << S.altSeq << endl;
	cout << "total mapped read: " << S.n_total_mapped_read << ",";
	cout << "total hQ-mapped read: " << S.n_total_hQ_mapped_read << ",";
	cout << "total no-indel reads: " << S.n_total_no_indel_read << ",";
	cout << "total hQ-base reads: " << S.n_total_hQ_base_read << ",";
	cout << "total not-end reads: " << S.n_total_not_end_read << ",";
	//cout << "low base qual reads: " << S.n_low_baseQual_read << ",";
	cout << "pos/neg direction reads: " <<  S.n_pos_direction_read <<"/" << S.n_neg_direction_read << ",";
	cout << "nearby SNP reads: " << S.n_nearby_SNP << endl;
	cout << "nearby indels: " << S.n_nearby_indel << endl;
	//cout << "end variations: " << S.n_end_readBase << endl;		
}

/**
	Input: LH_block structure reference and file pointer
	Output:
	-- writes information regarding a particular block
*/
void print_LH_block(LH_block& L,ofstream& outFs)
{
	outFs << "HCF block: " << L.blockStr << endl;
	outFs << "Chromosome: " << L.chrName << endl;
	outFs << "nSNP: " << L.nSNP << endl;
	for(int i=0;i<L.nSNP;i++)
		print_SNP_readInfo(L.readInfoSNP[i],outFs);
	outFs << endl;
	outFs << "good block: " << L.goodBlock << endl;
	outFs << endl;
}

/**
	Input: LH_block structure reference and file pointer
	Output:
	-- writes information regarding a particular block
*/
void print_LH_block(LH_block& L)
{
	cout << "HCF block: " << L.blockStr << endl;
	cout << "Chromosome: " << L.chrName << endl;
	cout << "nSNP: " << L.nSNP << endl;
	for(int i=0;i<L.nSNP;i++)
		print_SNP_readInfo(L.readInfoSNP[i]);
	cout << endl;
	cout << "good block: " << L.goodBlock << endl;
	cout << endl;
}

/**
	Input: chr id and position for one SNP, SNP array from VCF, INDEL array from VCF,type of match pointer, short_read length
	Output: matched or not boolean output and type of the match (returned by pointer)

	-- match the position of the block's one SNP with SNP or INDEL array in VCF file
	-- check if it is nearby 
	-- returns 0 if it is nearby to those existing SNPs/INDELs(i.e fails to pass the filter) or 1 otherwise 
*/
bool Level_2_Filtering_VCF(idPos tmpIdPos,vector<idPos>& F1,vector<idPos>& F2,int* tmpType,int short_RL,int filterType)
{
	/// Checking for indel or SNP exitence nearby from VCF file
	///// F1 is the SNP array from VCF file
	///// F2 is the INDEL array from VCF file
	
	bool bFlag = true;
	int near_snp_indel_max_dist = short_RL;
	if(filterType == ELEPHANT_FILTER)
		near_snp_indel_max_dist = ceil(short_RL*0.5);

	for(size_t i =0;i<F1.size();i++)
	{
		if(F1[i].chrID == tmpIdPos.chrID)
		{
			if( (abs(F1[i].pos - tmpIdPos.pos) > 0)  && 
				(abs(F1[i].pos - tmpIdPos.pos) <= near_snp_indel_max_dist) )
			{	
				bFlag = false;
				(*tmpType) = 1;
				return bFlag;
			}
		}
	}
	for(size_t i =0;i<F2.size();i++)
	{
		if(F2[i].chrID == tmpIdPos.chrID)
		{
			if( (abs(F2[i].pos - tmpIdPos.pos) > 0)  && 
				(abs(F2[i].pos - tmpIdPos.pos) <= near_snp_indel_max_dist) )
			{	
				bFlag = false;
				(*tmpType) = 2;
				return bFlag;
			}
		}
	}

 	return bFlag;
}


////// for VCF file manipulation ///////

FILE *vcfOpen (const char name[], const char md[])
{
 	/* opens file named in name with mode md.  If open fails, 
 	* prints an error msg and exits.  Else, returns the
 	* file pointer
 	*/
 FILE *FP;

 if ((FP = fopen (name, md)) == NULL)    
 {
      fprintf (stderr, "File\n<%s>\ncannot be opened for mode <%s>\n", name, md);
      exit (EXIT_FILE_ERR);
 }
 return FP;
}


void skipComments (FILE *fp, char *dl, char *hl)
{ /* Reads file pointed by fp, line by line.  Each comment line in it
 	 starts with a '#'.  This sub reads (and skips all comment lines.
 	 the last comment line is the header line - putsit in hl.
 	 first non-comment line is the data line - puts it in dl.
 	 Returns nothing */
	while (readNextLine (dl, fp) == 0)  
	{
 		/* If it is a comment, keep track as header line */
 		if (dl[0] == '#')
 	    { 
			strcpy (hl, dl);    
		}
        /* If not a comment, break out of this loop */
        else
        	break;  
 	}

 	return;
}


int readNextLine (char *l, FILE *f)
{
	/* Reads teh next line from f and puts it into l.  Returns chars read.
 	* Need a util on top of fgets to deal with the case where the line might
 	* be too long.  We'll leave it alone for now, but a malloc call may be needed
 	*/
 	if (fgets (l, MAX_LINE_LEN, f) == NULL) 
	{
 		/* NULL.  EOF was read.  reset l, return */
 		l[0] = '\0';
 		return 1;
 	}
 	else if (strlen (l) == MAX_LINE_LEN -1) 
	{
 	     /* Line too long - do some malloc stuff.
 	      * For now, just terminate and return. */
 	     fprintf (stderr, "Encountered line longer than %d:\n%s\n\nEnding ...\n", MAX_LINE_LEN, l);
 	     l[0] = '\0';
 	    return 2;
 	}
 	else    
	{
 	   /* Proper line read. Return 0 */
      return 0;
    }
}


int fieldNumber (const char *ln, const char *lfor, const char *delim)
{/* Tokenizes ln on delim and looks for lfor.  Returns the field number for lfor
    return -1 if not found */
 	int tk = 0;
 	char *token, dt[MAX_LINE_LEN];
  
 	strcpy (dt, ln);
 	token = strtok (dt, delim);
 	while (token != NULL)   
	{
 		if (strcmp (token, lfor) == 0)
 	        return (tk);    
 		else    
		{
 	    	token = strtok (NULL, delim);
	        ++tk;
 		}
 	}
 	/* All tokens exhausted.  lfor not found.  Return -1 */
 	return (-1);
}



char *getField (char *str, int n, const char *delim)
{
	/* split str by delim.  Return a pointer to the n'th field */
 	char *t;
 	int i = 0;
 	t = strtok (str, delim);
 	while (t != NULL)   
	{
    	if (i == n)
 	    { 
			return (t); 
		}
 		else    
		{
 	         t = strtok (NULL, delim);
 	         ++i;
 	    }
	}
 	/* all done before n't field could be reached
 	 * t right now is NULL.  Return it.  */
 	
	return (t);
} 

int altLen (char *a, int w)
{
 /* a is alternate sequence (potentially has multiple comma sep values). 
  * w is like 1, 2, 3, ... such that we have to take the 1'th, 2'th etc of the 
  * multiple values.   Here we return the length of the w'th element.  If w is 0,
  * return 1 */

	if (w == 0)
	{ 
		return 1;   
	}

	/* Which element do we want?  w'th */
	int len = 0, ele = 0; 
	while (*a != '\0')  
	{
    	if (*a == ',')  
		{
        	++ele;
        	if (ele == w)
        	{ 
				return (len);   
			}
        	len = 0; 
    	}    
    	else 
    	{ 
			++len;  
		}
    	++a; 
	}
	++ele;
	if (ele == w)
  	{ 
		return (len);   
	}
	else
  	{ 
		return -1;  
	}

}


void createParseString (char *str, int f)
{
	/* Creates a format string for use in sscanf.  We want to read
 	* 0'th field as string - chromosome
 	* 1'th field as int - position
 	* 3'th field as string - reference seq
 	* 4'th field as string - alternate sequence
 	* 8'th field as string - format_key_string
 	* f'th field as string - val_string for sample
 	*/
 	/*  Chr Pos ID Ref Alt Qua Fil Inf Fmt */
     /*  0  1   2   3  	4   5   6   7   8 */
 	strcpy (str, "%s %d %*s %s %s %*s %*s %*s %s");
  
 	/* f is guaranteed to be > 8 (prev error checking) */
 	/* Skip all fields except f */
 	int i;
 	/* ignore all fields till f'th */
 	for (i = 9; i < f; ++i)
 	{ 
		strcat (str, " %*s");   
	}
  
 	/* read f'th field as string */
 	strcat (str, " %s");
  
 	return;
}


void errorCheck (int rf, int af, int fkf, int svf)
{
 /* rf is reference field, af is alt_field, fkf, if "FORMAT" field and
  * svf is sample's format values field.  Here we do error checking.  If
  * format fails, exit.  Else return */
  
 	if ((svf < 8) || (rf != 3) || (af != 4) || (fkf != 8))  
	{
    	fprintf (stderr, "VCF file appears mal-formatted:\n\
          	 ref is in %d th field.  ALT is in %d the field.  FORMAT is in %d the field.  Sample is in %d the field\n", rf, af, fkf, svf);
      	/* Sample was not found or is among the first 9 fields */
		if (svf < 0)
 		{ fprintf (stderr, "Our Sample was not found in the VCF.\n"); }
 		else if (svf < 8)
 		{ fprintf (stderr, "Sample field is among the mandatory first 9 fields of the VCF.\n");   }
 		 
 		/* Other fields: ref, alt and format were not in the right place */
 		if (rf != 3)
 		{ fprintf (stderr, "Header line of VCF does not have REF as 4th field.\n");   }
 		if (af != 4)
 		{ fprintf (stderr, "Header line of VCF does not have ALT as 5th field.\n");   }
 		if (fkf != 8)
 		{ fprintf (stderr, "Header line of VCF does not have FORMAT as 9th field.\n");    }
 
      exit (EXIT_VCF_ERR);
    }
 	else
 	{ 
		return;     
	}

}

int getBamIDforChrom (string str1, SamHeader sH)
{
	string str2;
	SamSequenceDictionary sD(sH.Sequences);
	SamSequenceIterator sIt;	
	int i=0;
	for(sIt = sD.Begin();sIt != sD.End(); ++sIt)
	{
		str2.assign((*sIt).Name);
		if(str1.compare(str2) == 0)
		{
			//cout << str2 <<" ID = " << i << endl;
			return i;
		}
		i++;
	}
	
	// Not found.  Return -1 
  	return -1;
}


void getVCFInfo(const char vcfFileName[],const char sampleName[], SamHeader sH, vector<vcfInfo>& vcfVector)
{
	FILE *VCFP;
	int ref_field, alt_field, fmt_key_field, sample_val_field, hlen;
	char vcf_line[MAX_LINE_LEN], header_line[MAX_LINE_LEN];
	VCFP = vcfOpen (vcfFileName, "r");
	skipComments (VCFP, vcf_line, header_line);
  	hlen = strlen (header_line);
 	if (header_line[hlen-1] == '\n')
  	{ 
		header_line[hlen-1] = '\0'; 
	}
  	ref_field = fieldNumber (header_line, "REF", "\t");
  	alt_field = fieldNumber (header_line, "ALT", "\t");
  	fmt_key_field = fieldNumber (header_line, "FORMAT", "\t");
  	sample_val_field = fieldNumber (header_line, sampleName, "\t");
  	errorCheck (ref_field, alt_field, fmt_key_field, sample_val_field);

	/* Now vcf_line is the "next" (first) vcf_line.  Process them one by one till end*/
  	int posn, line_num = 1;
	//int num_printed = 0, target_id = -1, same;
  	//int Freq_Sig_Haplo[MAX_HAPLO_CALL+1], not_analyzed = 0;
  	char parse_string[MAX_LINE_LEN], chrom[MAX_LINE_LEN], ref_seq[MAX_LINE_LEN], alt_seq[MAX_LINE_LEN], fmt_key[MAX_LINE_LEN], fmt_val[MAX_LINE_LEN];
  	createParseString (parse_string, sample_val_field);

	while (vcf_line[0] != '\0') 
	{
		/* Get the chromosome, position, format_key and format_vals for our sample */
		//cout << vcf_line << endl;
 		sscanf (vcf_line, parse_string, chrom, &posn, ref_seq, alt_seq, fmt_key, fmt_val);
 		//cout << "info: " << chrom << ":" <<posn<<":"<<ref_seq<<":"<<alt_seq<<":"<<fmt_key<<":"<<fmt_val<<endl;		
			
 	    /* Get the format field number from the key and retrieve that field from the values */
 		int f;
 		char *v;
 		/* Ignore lines where there is no GT field in the format */
 		if ((f = fieldNumber (fmt_key, "GT", ":")) >= 0)    
		{
 			/* Get the GT value */
 			v = getField (fmt_val, f, ":");
 			//int lp = lastPosition (&this_block);
 
 			/* Can't read the genotype string, exit */
 			if ((strlen (v) != 3) || (v[1] != '/'))     
			{
 				fprintf (stderr, "Genotype %s not parseable on line %d of file (%s)\n", v, line_num, vcfFileName);
 				exit (EXIT_VCF_ERR);
 			}
 	        /* if its homozygous, or if indel (ref or alt > 1 NT long)*/
 			else 
			{
				vcfInfo vI;
				vI.chrom.assign(chrom);
				vI.iP.chrID = getBamIDforChrom (vI.chrom,sH);  
				vI.iP.pos = posn;
				
				if (v[0] == v[2])
				{
					//fprintf(stdout,"homozygous\n");
					vI.infoType = HOMOZYGOUS;
					//vcfVector.push_back(vI);
				}
				else 
				{
					if ( (strlen (ref_seq) != 1) || (altLen (alt_seq, v[0] - '0') != 1) || (altLen (alt_seq, v[2] - '0') != 1))
         			{    
						//fprintf(stdout,"indel\n");
						vI.infoType = INDEL;
						vcfVector.push_back(vI);
					}		
					else 
					{
						//fprintf(stdout,"heterozygous\n");		
						vI.infoType = HETEROZYGOUS;
						vcfVector.push_back(vI);
					}
				}
			}
		}	
		/*
          else if (((same = strcmp (chrom, this_block.chr)) == 0)
                      && ((posn - lp) < block_size))
            { addSNP (&this_block, posn, ref_seq);      }
          else    
		 {
              if ((this_block.nSNP > 1) && (this_block.nSNP <= MAX_SNPS)) 
			  {

			  }
		 }
		*/
		
		readNextLine (vcf_line, VCFP);
		++line_num;
	}
	//cout << "parsed "<< line_num << " lines in VCF file\n";
}

/**
	Input: line from HCF file, type of filter and short read length
	Output: boolean variable to find if the block passes level_1 filter,chr name, nSNP, position of those SNPs, reference sequence, subfilter type that applied
	-- Level_1 or HCF level filtering
	-- returns 0 if it fails to pass the level-1 filter 	 
	-- This filter removed most of the blocks
	-- min_SNP_distance is short_RL for TAIL and LEG filter and short_RL/2 for ELEPHANT filter
	-- For TAIL filter: blocks are removed if any two SNPs are closer than min_SNP_distance or the block does not have >2 nHaplo or >2 nClus
	-- For LEG filter:  blocks are removed if any two SNPs are closer than min_SNP_distance or the block does not have >2 nHaplo
	-- For ELEPHANT filter: blocks are removed if any two SNPs are closer than min_SNP_distance(=short_RL/2) or the block does not have >2 nHaplo
*/
bool Level_1_Filtering_HCF(char* inLineStr,char* tmpName,int* nSNP,long* posSNP,char* refSeq,
							int* tmpType,int short_RL,int filterType)
{
	bool bFlag = true;
	
	string tStr;
	tStr.assign(inLineStr);

	string chrName;
	string delimiter1 = "\t";
	string delimiter2 = ",";
	string delimiter3 = ";";
	string delimiter4 = "=";
	size_t pos1 = 0,pos2 = 0,pos3 = 0,pos4 = 0;
	int cnt1   = 0;
	string token1,token2,token3,token4;
	(*nSNP) = 0;
	int nHaplo;
	string nClus_str;
	int nClus;
	while ((pos1 = tStr.find(delimiter1)) != string::npos) 
	{
    	token1 = tStr.substr(0,pos1);
		cnt1++;
    	//cout << "token 1: " << token1 << endl;
    	tStr.erase(0,pos1 + delimiter1.length());
		
		switch(cnt1)
		{
			case 1:	chrName.assign(token1);
					//cout << " name: " << chrName << endl;
					strcpy(tmpName,chrName.c_str());
					break;		
			case 2:	(*nSNP) = 0;
					while ((pos2 = token1.find(delimiter2)) != string::npos)
					{ 
    					token2 = token1.substr(0,pos2);
						posSNP[(*nSNP)] = atol(token2.c_str());
						(*nSNP)++;
    					token1.erase(0,pos2 + delimiter2.length());
					}	
    				token2 = token1.substr(0,token1.size());
					posSNP[(*nSNP)] = atol(token2.c_str());
					(*nSNP)++;
					//cout << " nSNP = " << (*nSNP) << endl;
					break;
			case 3:	for(int i=0;i<(*nSNP);i++)
						refSeq[i] = token1.at(i);
					//cout << " Ref = " << refSeq << endl;
					break;
			
			case 4: nHaplo = atoi(token1.c_str());
					//cout << " nHaplo = " << nHaplo << endl;
					break;	
			case 7: while ((pos3 = token1.find(delimiter3)) != string::npos)
					{ 
    					token3 = token1.substr(0,pos3);
    					//cout << "token 3: " << token3 << endl;
						token1.erase(0,pos3 + delimiter3.length());
					}	
					nClus_str.assign(token3.c_str());
					//cout << "n_clus_str: " << nClus_str << endl;	
					pos4 = nClus_str.find(delimiter4);				
    				token4 = nClus_str.substr(pos4+1,nClus_str.length());
					nClus = atoi(token4.c_str());
    				//cout << "nClus: " << nClus << endl;
					break;	

			default: break;
		}
	}

	//cout << "cnt1: " << cnt1 << endl;
	if(cnt1 == 6) // for usual HCF
	{
    	//cout << "tStr: " << tStr << endl;
		string tmpStr(tStr);
	
		while((pos3 = tmpStr.find(delimiter3)) != string::npos)
		{ 
    		token3 = tmpStr.substr(0,pos3);
    		//cout << "token 3: " << token3 << endl;
			tmpStr.erase(0,pos3 + delimiter3.length());
		}	
		nClus_str.assign(token3.c_str());
		//cout << "n_clus_str: " << nClus_str << endl;	
		pos4 = nClus_str.find(delimiter4);				
    	token4 = nClus_str.substr(pos4+1,nClus_str.length());
		nClus = atoi(token4.c_str());
    	//cout << "nClus: " << nClus << endl;
	}
	
	/*
	cout << "name: " << chrName << "\t";
	cout << "nSNP: " << (*nSNP) << "\t";
	if( (*nSNP) == 2)
		cout << "pos: " << posSNP[0] <<" , " << posSNP[1] << "\t";
	if( (*nSNP) == 3)
		cout << "pos: " << posSNP[0] <<" , " << posSNP[1] << " , " << posSNP[2] <<"\t";

	cout << "ref: " << refSeq << "\t";
	cout << "nHaplo: " << nHaplo << "\t";
	cout << "nClus: " << nClus << "\n";
	*/

	int min_between_snp_dist;

	if(filterType == ELEPHANT_FILTER)
		min_between_snp_dist = ceil(short_RL*0.5);
	else
		min_between_snp_dist = short_RL;

	//cout << "min_between_snp_dist = " << min_between_snp_dist << endl;

	if((*nSNP)==2)
	{
		if( (posSNP[1] - posSNP[0]) <= min_between_snp_dist)
		{
			bFlag = false;
			(*tmpType) = 1;
			return bFlag;
		}
	}
	if((*nSNP) == 3)
	{
		if( (posSNP[1] - posSNP[0] <= min_between_snp_dist) || ((posSNP[2] - posSNP[1] <= min_between_snp_dist)) )
		{
			bFlag = false;
			(*tmpType) = 1;
			return bFlag;
		}

	}
	
	if(filterType == TAIL_FILTER)	
	{
		if(nHaplo < N_HAPLO || nClus < N_CLUSTER)
		{
			bFlag = false;	
			(*tmpType) = 2;
			return bFlag;	
		}
	}
	else /// LEG and ELEPHANT Filtering
	{
		if(nHaplo < N_HAPLO)
		{
			bFlag = false;	
			(*tmpType) = 2;
			return bFlag;	
		}
	}
		
	return bFlag;	
	
}


/// =========================================
/// Level-3 BAM Filtering
/**
*	Input: BAM reader, alignment of BAM corresponding to one SNP,LH_block structure reference, SNP's pos, reference seq,
*		   short read length
*	Output: boolean variable to if the SNP passes level_3 filter, level_3 subfilter counts for Level_3 filters		
*		-- this is the main module for BAM level filtering
*		-- get all the aligned reads that covers the SNP
*		-- find mapping quality,QCFailed flag, Duplicate Flag and associated error string (1)
*		-- find indel sites that might exist on any read (2) 
*		-- find the base quality of that call in the read (3)
*		-- find if the SNP position is at the end of a particular read (4)
*		-- find all the reads that pass these checks (1),(2),(3),(4);
*		-- among them find how many of those reads are in these following four groups
*			-- major allele forward direction
*			-- major allele reverse direction
*			-- minor allele forward direction
*			-- minor allele reverse direction
*		-- test if all the numbers are at least > ALLELE_MIN_CNT (=1, currently)
*		-- if yes, the test for Fisher strand bias test on those four numbers
*		-- return 1 for that SNP if all pass
*		-- Otherwise return 0 to indicate that this SNP does not pass the filter criteria so is the block
*		   because in order for a block to pass the filters, all the SNPs in that block have to pass the filters individually.				
*/

bool Level_3_Filtering_BAM(BamReader& bR, BamAlignment& al, LH_block& LH_blk,int i,long posSNP[],char refSeq[],int short_RL,
								int& level_3_subfilter_rem_cnt_1,int& level_3_subfilter_rem_cnt_2,
                                int& level_3_subfilter_rem_cnt_3,int& level_3_subfilter_rem_cnt_4)
{

	int min_dist_end_read = ceil(short_RL*END_DIST_RATIO);
	//cout <<"min_dist_end_read = " << min_dist_end_read << endl; 

	while ( bR.GetNextAlignment(al) ) 
	{					
		int relativePosRead = 0;
		//int RL1 = al.Length;
		int RL2 = al.AlignedBases.size();
		//int RL3 = al.Qualities.size();
		//int RL4 = al.QueryBases.size();
			
		LH_blk.readInfoSNP[i].n_total_mapped_read++;

		//cout << "read name: " << al.Name << endl;
		//cout << "start pos: " << al.Position << endl;
		//cout << "length: " << RL1 << " :: " << RL2 << endl; 
		char chSeq;
		/// filter out the reads those 
					
		if(al.MapQuality >= MIN_MAP_QUAL 
			&& al.IsFailedQC() == false 
			&& al.IsDuplicate() == false) 
		{
			int sQ;
			LH_blk.readInfoSNP[i].n_total_hQ_mapped_read++;
			if(indelExistBAM(al) == false)
			{
				LH_blk.readInfoSNP[i].n_total_no_indel_read++;
				relativePosRead = (posSNP[i]-1)-al.Position;	
				char altSeq;
				if(relativePosRead >= (int) (al.AlignedBases.length()) || relativePosRead < 0) 
				{
					cout << "**** error **** !!!" << endl;	
					sQ = 0;
				}
				else
				{
					sQ = al.Qualities.at(relativePosRead) - PHRED_QUAL_OFFSET; // they store Quality+33 
					altSeq = al.AlignedBases.at(relativePosRead);
					//cout << "read name: "<< al.Name <<" ref. base: " << refSeq[i] << " alt. base: " << altSeq << " Qual: " << sQ <<  endl; 
				}		
				int start_boundary,end_boundary; 
								
				start_boundary = min_dist_end_read;
				end_boundary = al.Position + RL2 - min_dist_end_read;
								
				if( (sQ >= MIN_BASE_QUAL) )
				{
					LH_blk.readInfoSNP[i].n_total_hQ_base_read++;
					if( (relativePosRead > start_boundary) && (relativePosRead < end_boundary) )
					{
						LH_blk.readInfoSNP[i].n_total_not_end_read++;
						chSeq = al.AlignedBases.at(relativePosRead);
						//cout << "seq char at " << relativePosRead+1 <<  " = " << chSeq << endl;
						/*
						#ifdef	ONLY_MUTATION_DIR_READ										
						if(altSeq != refSeq[i])
						#else
						if(altSeq != refSeq[i] || altSeq == refSeq[i])
						#endif
						{
							LH_blk.readInfoSNP[i].n_total_good_alt_read++;
							if(al.IsReverseStrand()==0)
                            {
                            	LH_blk.readInfoSNP[i].n_pos_direction_read++;
                            }
                            else
                            {
                            	LH_blk.readInfoSNP[i].n_neg_direction_read++;                                   
                            }
						}
						*/
						
						LH_blk.readInfoSNP[i].n_total_good_read++;
						
						// new method of testing by z-test of proportion
						if(al.IsReverseStrand()==0) 	
                        {
							LH_blk.readInfoSNP[i].n_tot_pos_direction_read++;                                   
							if(altSeq != refSeq[i])
								LH_blk.readInfoSNP[i].n_mut_pos_direction_read++;                                   
							
						}
						else
						{
							LH_blk.readInfoSNP[i].n_tot_neg_direction_read++;                                   
							if(altSeq != refSeq[i])
								LH_blk.readInfoSNP[i].n_mut_neg_direction_read++;                                   
								
						}

					}
				}
			}
		}

	} /// end while: for all the blocks for a particular SNP
	cout << "total mapped read count = " << LH_blk.readInfoSNP[i].n_total_mapped_read << endl;
	cout << "total hQ-mapped read count = " << LH_blk.readInfoSNP[i].n_total_hQ_mapped_read << endl;
	cout << "total no-indel read count = " << LH_blk.readInfoSNP[i].n_total_no_indel_read << endl;
	cout << "total hQ-base read count = " << LH_blk.readInfoSNP[i].n_total_hQ_base_read << endl;
	cout << "total not-end read count = " << LH_blk.readInfoSNP[i].n_total_not_end_read << endl;
	cout << "total good read count = " << LH_blk.readInfoSNP[i].n_total_good_read << endl;
	
	//cout << "total good alt. +dir read count = " << LH_blk.readInfoSNP[i].n_pos_direction_read << endl;
	//cout << "total good alt. -dir read count = " << LH_blk.readInfoSNP[i].n_neg_direction_read << endl;
	
	cout << "total good total +dir read count = " << LH_blk.readInfoSNP[i].n_tot_pos_direction_read << endl;
	cout << "total good mutant +dir read count = " << LH_blk.readInfoSNP[i].n_mut_pos_direction_read << endl;
	cout << "total good total -dir read count = " << LH_blk.readInfoSNP[i].n_tot_neg_direction_read << endl;;
	cout << "total good mutant -dir read count = " << LH_blk.readInfoSNP[i].n_mut_neg_direction_read << endl;;
	
	cout <<  endl;
	int n1,x1,n2,x2;
	n1 = LH_blk.readInfoSNP[i].n_tot_pos_direction_read;
	x1 = LH_blk.readInfoSNP[i].n_mut_pos_direction_read;
	n2 = LH_blk.readInfoSNP[i].n_tot_neg_direction_read;
	x2 = LH_blk.readInfoSNP[i].n_mut_neg_direction_read;

	// level-3 sub-filter counting

	/*
	if(LH_blk.readInfoSNP[i].n_total_hQ_mapped_read == 0)
		level_3_subfilter_rem_cnt_1++;
	if(LH_blk.readInfoSNP[i].n_total_hQ_mapped_read > 0 && LH_blk.readInfoSNP[i].n_total_no_indel_read == 0)
		level_3_subfilter_rem_cnt_2++;
	if(LH_blk.readInfoSNP[i].n_total_hQ_mapped_read > 0 
		&& LH_blk.readInfoSNP[i].n_total_no_indel_read > 0
		&& LH_blk.readInfoSNP[i].n_total_hQ_base_read == 0)
		level_3_subfilter_rem_cnt_3++;
	if(LH_blk.readInfoSNP[i].n_total_hQ_mapped_read > 0 
		&& LH_blk.readInfoSNP[i].n_total_no_indel_read > 0
		&& LH_blk.readInfoSNP[i].n_total_hQ_base_read > 0
		&& LH_blk.readInfoSNP[i].n_total_not_end_read == 0)
		level_3_subfilter_rem_cnt_4++;
				

	double pos_prop_dir = 1.0;
	double neg_prop_dir = 0.0;
	if(LH_blk.readInfoSNP[i].n_total_good_read != 0)
	{
		pos_prop_dir = (LH_blk.readInfoSNP[i].n_pos_direction_read*1.0)/LH_blk.readInfoSNP[i].n_total_good_read;
		neg_prop_dir = (LH_blk.readInfoSNP[i].n_neg_direction_read*1.0)/LH_blk.readInfoSNP[i].n_total_good_read;
	}
				
	double max_prop_dir = pos_prop_dir;
	if(neg_prop_dir > max_prop_dir)
		max_prop_dir = neg_prop_dir;

	*/

	bool zFlag = false;
	if(LH_blk.readInfoSNP[i].n_total_good_read != 0)
	{
	
		//zFlag = passed_two_proportions_z_test(x1,n1,x2,n2);
		zFlag = passed_Fisher_exact_test(x1,n1,x2,n2);	

	}

	//if(max_prop_dir < PROPORTION_DIR_READ)
	//	zFlag = true;		

	return zFlag;

}


/**
	Input: BAM alignment reference
	Output: 1 if INDEL exists
		-- determined from CIGAR string
*/
bool indelExistBAM(BamAlignment& B)
{
	//// for CIGAR
	//// M/=/X are when we can just read
	//// S or I is like insert
	//// D or N is like delete

	bool bRet = false;
	//cout << "CIGAR: vector size " << B.CigarData.size() << endl;
	for(size_t i=0;i<B.CigarData.size();i++)
	{
		//cout << "CIGAR: " << B.CigarData[i].Length << B.CigarData[i].Type << endl;
		if(B.CigarData[i].Type == 'D' || B.CigarData[i].Type == 'I')
		{
			if(B.CigarData[i].Length > 0)
			{
				bRet = true;
				return bRet;
			}
		}
	}

	return bRet;
}


/// not used:
/// wanted to use it for finding out relative position of an SNP in a particular read 

int returnRelativePosOnRead(BamAlignment &B,int snpPos,int short_RL)
{
	string cigarStr;
	int relativeReadPos = 0;
	int targetReadPos = snpPos-1;
	cout << "CIGAR: vector size " << B.CigarData.size() << endl;
	int strtReadPos = B.Position;	
	for(size_t i=0;i<B.CigarData.size();i++)
	{
		cout << "CIGAR: " << B.CigarData[i].Length << B.CigarData[i].Type << endl;
		if(B.CigarData[i].Type == 'M' || B.CigarData[i].Type == '=' || B.CigarData[i].Type == 'X')
		{
			//for(int k=0;k<B.CigarData[i].Length;k++)
			//{
			cigarStr.append(B.CigarData[i].Length,'M');	
				
			//}
			cout << "str: " << cigarStr << endl;
		}
		if(B.CigarData[i].Type == 'D' || B.CigarData[i].Type == 'N')
		{
			cigarStr.append(B.CigarData[i].Length,'D');	
			
			cout << "str: " << cigarStr << endl;
		}
		if(B.CigarData[i].Type == 'I' || B.CigarData[i].Type == 'S')
		{
			cigarStr.append(B.CigarData[i].Length,'I');	
			cout << "str: " << cigarStr << endl;
		}
	}
	
	cout << "length = " << cigarStr.length() << endl;
	int tmpPos = strtReadPos;
	for(size_t i=0;i<cigarStr.length();i++)
	{
		if(cigarStr.at(i) == 'M')
			; // do nothing
		if(cigarStr.at(i) == 'D')
			strtReadPos = strtReadPos + 1;
		if(cigarStr.at(i) == 'I')
			;//strtReadPos = strtReadPos - 1;
		tmpPos = tmpPos+1;
		if(tmpPos > targetReadPos)
			break;
	}		
	relativeReadPos = targetReadPos - strtReadPos + 1;
	//if(j != short_RL)
	//	cout << "str: " << cigarStr <<" :::error !!! " << " j = " << j << endl;
	return relativeReadPos;
}

/// this proportion Z-test is not used right now; instead Fisher's strand bias (hypergeometric) test is getting used
bool passed_two_proportions_z_test(int x1,int n1,int x2,int n2)
{
	bool zFlag = true;
	if( (n1 == 0) || (n2 == 0) || (x1 == 0) || (x2 == 0) || (x1 > n1) || (x2 > n2) )
	{
		cout << "error in z_test !!! \n"<< endl;
		zFlag = false;
		return zFlag;
	}

	double p1 = (x1*1.0)/n1;
	double p2 = (x2*1.0)/n2;

	double p  = ((x1+x2)*1.0)/(n1+n2);
	
	double se = sqrt(p*(1.0-p)*(1.0/n1+1.0/n2));
	
	//cout <<"p1 = " << p1 << " p2 = " << p2 << " p = " << p << " se = " << se << endl; 

	double z = (p2-p1)/se;

	//// two sided z-test
	
	double z_abs = fabs(z);

	cout << "[z= " << z <<" z_abs= " << z_abs <<"]" << endl;

	double z_val_threshold = calculate_z_value(P_VAL_SIG_LEVEL);

	if(z_abs > z_val_threshold) 
		zFlag = false; 
	

	return zFlag;

} 

/*
 Fisher 2-by-2 exact test:
 it is part of a statistical test functions utility
 developed by Christopher Chang in BGI Cognitive genomics 
 https://www.cog-genomics.org/software/stats
 which  was covered by GPLv3
*/
double fisher2by2(uint32_t m11, uint32_t m12, uint32_t m21, uint32_t m22, uint32_t midp) {
  // Basic 2x2 Fisher exact test p-value calculation.
  double tprob = (1 - SMALL_EPSILON) * EXACT_TEST_BIAS;
  double cur_prob = tprob;
  double cprob = 0;
  int32_t tie_ct = 1;
  uint32_t uii;
  double cur11;
  double cur12;
  double cur21;
  double cur22;
  double preaddp;
  // Ensure we are left of the distribution center, m11 <= m22, and m12 <= m21.
  if (m12 > m21) {
    uii = m12;
    m12 = m21;
    m21 = uii;
  }
  if (m11 > m22) {
    uii = m11;
    m11 = m22;
    m22 = uii;
  }
  if ((((uint64_t)m11) * m22) > (((uint64_t)m12) * m21)) {
    uii = m11;
    m11 = m12;
    m12 = uii;
    uii = m21;
    m21 = m22;
    m22 = uii;
  }
  cur11 = m11;
  cur12 = m12;
  cur21 = m21;
  cur22 = m22;
  while (cur12 > 0.5) {
    cur11 += 1;
    cur22 += 1;
    cur_prob *= (cur12 * cur21) / (cur11 * cur22);
    cur12 -= 1;
    cur21 -= 1;
    if (cur_prob < EXACT_TEST_BIAS) {
      if (cur_prob > (1 - 2 * SMALL_EPSILON) * EXACT_TEST_BIAS) {
        tie_ct++;
      }
      tprob += cur_prob;
      break;
    }
    cprob += cur_prob;
    if (cprob == INFINITY) {
      return 0;
    }
  }
  if ((cprob == 0) && (!midp)) {
    return 1;
  }
  if (cur12 > 0.5) {
    do {
      cur11 += 1;
      cur22 += 1;
      cur_prob *= (cur12 * cur21) / (cur11 * cur22);
      cur12 -= 1;
      cur21 -= 1;
      preaddp = tprob;
      tprob += cur_prob;
      if (tprob <= preaddp) {
	break;
      }
    } while (cur12 > 0.5);
  }
  if (m11) {
    cur11 = m11;
    cur12 = m12;
    cur21 = m21;
    cur22 = m22;
    cur_prob = (1 - SMALL_EPSILON) * EXACT_TEST_BIAS;
    do {
      cur12 += 1;
      cur21 += 1;
      cur_prob *= (cur11 * cur22) / (cur12 * cur21);
      cur11 -= 1;
      cur22 -= 1;
      preaddp = tprob;
      tprob += cur_prob;
      if (tprob <= preaddp) {
        if (!midp) {
	  return preaddp / (cprob + preaddp);
        } else {
          return (preaddp - ((1 - SMALL_EPSILON) * EXACT_TEST_BIAS * 0.5) * tie_ct) / (cprob + preaddp);
        }
      }
    } while (cur11 > 0.5);
  }
  if (!midp) {
    return tprob / (cprob + tprob);
  } else {
    return (tprob - ((1 - SMALL_EPSILON) * EXACT_TEST_BIAS * 0.5) * tie_ct) / (cprob + tprob);
  }
}


/**
	Input: #-of FWD direction mutated read, #-of total FWD direction read,   
		   #-of REV direction mutated read,#-of total REV direction read   
	Output: 1 if Fisher's strand bias test passed, 0 otherwise
		-- calls the fisher2by2 function in fisherExact.cpp  	
*/

bool passed_Fisher_exact_test(int x1,int n1,int x2,int n2)
{
	bool zFlag = true;
	if( (n1 == 0) || (n2 == 0) || (x1 == 0) || (x2 == 0) || (x1 > n1) || (x2 > n2) )
	{
		cout << "error in Fisher exact test !!! \n"<< x1 << "\t" << n1 << "\t" << x2 << "\t" << n2 << endl;
		zFlag = false;
		return zFlag;
	}
	
	
	double d,p;
	/*
	int h1,h2,h3;
	h1 = n_choose_k(n1,x1);
	h2 = n_choose_k(n2,x2);

	int n = n1+n2;
	int x = x1+x2;

	h3 = n_choose_k(n,x);

	d = (h1*h2)/h3;

	*/
	int m11,m12,m21,m22,midp;
	m11 = x1;
	m12 = n1-x1;
	m21 = x2;
	m22 = n2-x2;
	// do we need it ??
	// we can also test minimum count filter i.e.
	if(m11 < ALLELE_MIN_CNT || m12 < ALLELE_MIN_CNT || m21 < ALLELE_MIN_CNT || m22 < ALLELE_MIN_CNT )
	{
		zFlag = false;
		return zFlag;
	}

	midp = 0;
	//// two-sided fisher-exact-test	
	p = fisher2by2(m11, m12, m21, m22, midp);
	cout << "Fisher exact test p-val = " << p << endl;
	d = 1-p;	
	if(d > FISHER_P_VAL_THRESHOLD)
		zFlag = false;

	return zFlag;

}

/// not used now
double compute_quantile(int* x,int n,double f)
{
	int i;
	double delta;
	
	i = floor((n-1)*f);
	delta = (n-1)*f - i;

	double q = (1-delta) * x[i] + delta * x[i+1];

	return q;
}


//// functions to compute the inverse of the normal CDF

double RationalApproximation(double t)
{
    // Abramowitz and Stegun formula 26.2.23.
    // The absolute value of the error should be less than 4.5 e-4.
    double c[] = {2.515517, 0.802853, 0.010328};
    double d[] = {1.432788, 0.189269, 0.001308};
    return t - ((c[2]*t + c[1])*t + c[0]) / 
               (((d[2]*t + d[1])*t + d[0])*t + 1.0);
}

double NormalCDFInverse(double p)
{
    if (p <= 0.0 || p >= 1.0)
    {
        cout << "Invalid input argument !! " << endl; 
    	cout << "setting to default sig-level = 0.05" << endl;
		p = 0.025;
	}

    // See article above for explanation of this section.
    if (p < 0.5)
    {
        // F^-1(p) = - G^-1(p)
        return -RationalApproximation( sqrt(-2.0*log(p)) );
    }
    else
    {
        // F^-1(p) = G^-1(1-p)
        return RationalApproximation( sqrt(-2.0*log(1-p)) );
    }
}

double calculate_z_value(double p_val_sig)
{
	double prob = 0.5*p_val_sig;
	double z_val = NormalCDFInverse(prob);

	return (abs(z_val));

}

/// function to compute nCk - combination of k-items from n-items
int n_choose_k(int n,int k)
{
    if (k > n) return 0;
    if (k * 2 > n) k = n-k;
    if (k == 0) return 1;

    int result = n;
    for( int i = 2; i <= k; ++i ) {
        result *= (n-i+1);
        result /= i;
    }
    return result;
}

